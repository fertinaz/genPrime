package main

import (
	"os"
	"fmt"
	"time" 
	"flag" 
	"strings"
	"strconv"
)

func getRange() (left, right int) {

	const MaxInt uint64 = 1<<64 - 1

	var isPosInt bool

	// Keep asking until input format is correct
	for isPosInt == false {
		fmt.Print("Enter left bound of the range: ")
		fmt.Scanf("%d \n", &left)

		if left < 1 || uint64(left) > MaxInt {
			fmt.Printf("Value must be a non-negative integer smaller than: %v \n", MaxInt)
		} else {
			isPosInt = true
		}
	}

	isPosInt = false
	for isPosInt == false {
		fmt.Print("Enter right bound of the range: ")
		fmt.Scanf("%d", &right)

		if right < 1 || right < left || uint64(right) > MaxInt {
			fmt.Printf("Value must be a non-negative integer larger than the first value and smaller than: %v \n", MaxInt)
		} else {
			isPosInt = true
		}
	}

	return
}

func checkPrime(num int) bool {

	var temp int

	// Iterate over every smaller integer and check remainder.
	// 0 remainder means number is divisible
	for i := 3; i < num/2; i++ {
		temp = num % i
		if temp == 0 {
			return false
		}
	}

	return true
}

func printSlice(s []int) {
	fmt.Printf("List of prime numbers: %v \n", s)
}

func main() {

	const MaxInt uint64 = 1<<64 - 1

	var isPrime bool
	var primes []int

	// Get interval from the stdin
	// var lowerBound, upperBound = getRange()
	// fmt.Printf("Interval: [%v, %v] \n", lowerBound, upperBound)

	// Setup command-line arguments -- range
	var rangeStr string
	flag.StringVar(&rangeStr, "range", "", "Input range should be non-negative integers. Ex: [1, 10]")

	// Setup command-line arguments -- prime number detection algorithm (integer)
	algoPtr := flag.Int("algorithm", 1, "Specify generation algorithm. 1 for basic, 2 for Sieve of Eratosthenes, 3 for other.")

	// Setup command-line arguments -- print to screen (true / false)
	printPtr := flag.Bool("print", true, "Print results to stdout")

	// Parse flags
	flag.Parse()	

	// Check format -- range
	fmt.Println("range:", rangeStr)
	s := strings.Split(rangeStr, ",")
	
	// lowerBound must a non-negative integer
	lowerBound, err := strconv.Atoi(s[0])
	if err == nil {
		if lowerBound < 1 || uint64(lowerBound) > MaxInt {
			fmt.Printf("Value must be a non-negative integer smaller than: %v \n", MaxInt)
			os.Exit(1)
		}
	} else {
		fmt.Printf("Format error: %v \n", err)
		os.Exit(1)
	}
	
	upperBound, err := strconv.Atoi(s[1])
	if err == nil {
		if upperBound < 1 || upperBound < lowerBound || uint64(upperBound) > MaxInt {
			fmt.Printf("Value must be a non-negative integer smaller than: %v \n", MaxInt)
			os.Exit(1)
		}

	} else {
		fmt.Printf("Format error: %v \n", err)
		os.Exit(1)
	}

	// fmt.Printf("Interval: [%T %v, %T %v] \n", lowerBound, lowerBound, upperBound, upperBound)
	fmt.Println("algorithm:", *algoPtr)
	fmt.Println("print:", *printPtr)

	// Now adjust lower bound: 2 is the smallest prime number
	if lowerBound < 3 {
		primes = append(primes, 2)
		lowerBound = 3
	}

	// Now adjust lower bound: even numbers cannot be prime, so no need to iterate over them
	if lowerBound%2 == 0 {
		lowerBound++
	}

	// Start measuring
	start := time.Now()
	for i := lowerBound; i < upperBound; i += 2 {

		isPrime = checkPrime(i)

		// Found prime number. Append it and update the flag
		if isPrime {
			primes = append(primes, i)
			isPrime = false
		}
	}

	// Print measured time
	t := time.Now()
	elapsed := t.Sub(start)
	fmt.Printf("Elapsed time: %v \n", elapsed)
	
	printSlice(primes)
}